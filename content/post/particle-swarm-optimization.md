---
title: 粒子群算法
authors:
  - Shenghui Gu
date: "2018-10-28T15:42:00+08:00"
lastmod: "2021-08-24T23:12:35+08:00"
tags:
  - Particle Swarm Optimization
  - Heuristic Algorithm
---

## 粒子群算法

粒子群算法，也称粒子群优化算法或鸟群觅食算法，来源于对一个简化社会模型的模拟。
PSO 算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”（Crossover）和“变异”（Mutation）操作，它通过追随当前搜索到的最优值来寻找全局最优。
这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。
粒子群算法是一种并行算法。

<!-- more -->

## 算法原理

设想这样一个场景：一群鸟在随机搜索食物。
在这个区域里只有一块食物。
所有的鸟都不知道食物在那里。
但是他们知道当前的位置离食物还有多远。
那么找到食物的最优策略是什么呢。
最简单有效的就是搜寻目前离食物最近的鸟的周围区域。

PSO 从这种模型中得到启示并用于解决优化问题。
PSO 中，每个优化问题的解都是搜索空间中的一只鸟。
我们称之为“粒子”。
所有的粒子都有一个由被优化的函数决定的适应值（fitness value），每个粒子还有一个速度决定他们飞翔的方向和距离。
然后粒子们就追随当前的最优粒子在解空间中搜索。

PSO 算法是基于群体的，根据对环境的适应度将群体中的个体移动到好的区域。
然而它不对个体使用演化算子，而是将每个个体看作是{{< math >}}$D${{< math >}}维搜索空间中的一个没有体积的微粒（点），在搜索空间中以一定的速度飞行，这个速度根据它本身的飞行经验和同伴的飞行经验来动态调整。
第{{< math >}}$i${{< math >}}个微粒表示为{{< math >}}$X_i = (x\_{i1}, x\_{i2}, ..., x\_{iD})${{< math >}}，它经历过的最好位置（有最好的适应值）记为{{< math >}}$P_i = (p\_{i1}, p\_{i2}, ..., p\_{iD})${{< math >}}，也称为{{< math >}}$pBest${{< math >}}。
在群体所有微粒经历过的最好位置的索引号用符号{{< math >}}$g${{< math >}}表示，即{{< math >}}$P_g${{< math >}}，也称为{{< math >}}$gBest${{< math >}}。
微粒{{< math >}}$i${{< math >}}的速度用{{< math >}}$V_i = (v\_{i1}, v\_{i2}, ..., v\_{iD})${{< math >}}表示。
对每一代，它的第{{< math >}}$d${{< math >}}维{{< math >}}$(1 ≤ d ≤ D)${{< math >}}根据如下方程进行变化：

{{< math >}}
$$
v\_{id} = w \cdot v\_{id} + c_1 \cdot rand() \cdot (p\_{id} - x\_{id}) + c_2 \cdot rand() \cdot (p\_{gd} - x\_{id}) \\
x\_{id} = x\_{id} + v\_{id}
$$
{{< math >}}

其中{{< math >}}$w${{< math >}}为惯性权重（Inertia Weight），{{< math >}}$c_1${{< math >}}和{{< math >}}$c_2${{< math >}}为加速常数（Acceleration Constants），rand()为在[0,1]范围里变化的随机值。
此外，微粒的速度{{< math >}}$V_i${{< math >}}被一个最大速度{{< math >}}$V\_{max}${{< math >}}所限制。
如果当前对微粒的加速导致它的在某维的速度{{< math >}}$v\_{id}${{< math >}}超过该维的最大速度{{< math >}}$v\_{max,d}${{< math >}}，则该维的速度被限制为该维最大速度{{< math >}}$v\_{max,d}${{< math >}}。

## 算法流程

1. 初始化一群微粒（群体规模为{{< math >}}$m${{< math >}}），包括随机的位置和速度；
2. 评价每个微粒的适应度；
3. 对每个微粒，将它的适应值和它经历过的最好位置{{< math >}}$pBest${{< math >}}的作比较，如果较好，则将其作为当前的最好位置{{< math >}}$pBest${{< math >}}；
4. 对每个微粒，将它的适应值和全局所经历最好位置{{< math >}}$gBest${{< math >}}的作比较，如果较好，则重新设置{{< math >}}$gBest${{< math >}}的索引号；
5. 根据上述方程变化微粒的速度和位置；
6. 如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数{{< math >}}$G\_{max}${{< math >}}），回到 2。
